# Going Tall: Migration Strategy for Differential Expression Data Model

**Note:** this is still a rough cut!

## Executive Summary

This document outlines the implications of transitioning the gene expression data model from **wide format** (one column per gene) to **tall format** (gene identifier and expression value as separate columns). The primary driver is front-end efficiency: computing metadata for 20,000+ gene variables is slow, and displaying them in the UI is unwieldy.

**Key Finding**: The migration requires changes primarily at the **Java ingestion layer**. The R computation code (`veupathUtils::differentialExpression`) can remain largely unchanged, as it already expects wide format internally.

---

## Current Data Flow (Wide Format)

### 1. Data Structure
```
Sample as rows, genes as columns:
sampleID | EUPA_0000123.ENSG00000001 | EUPA_0000123.ENSG00000002 | ... | EUPA_0000123.ENSG00020000
---------|---------------------------|---------------------------|-----|--------------------------
sample1  | 42                        | 100                       | ... | 0
sample2  | 38                        | 95                        | ... | 1
```

### 2. Collection Concept
- A **collection** IS the structural set of 20,000 column variables
- Each gene is a distinct `VariableDef` with its own `variableId` (stable_id)
- `util.getCollectionMembers(collectionSpec)` returns 20,000 `VariableSpec` objects
- Collection configuration: `entityId + collectionVariable`

### 3. Column Naming Convention
Column names follow the pattern: `entityId.variableId`
- Example: `EUPA_0000123.ENSG00000001`
- This is generated by `VariableDef.toDotNotation()` (VariableDef.java:170-171)

### 4. How Data Reaches R
**DifferentialExpressionPlugin.java:80-84**:
```java
List<VariableSpec> computeInputVars = ListBuilder.asList(computeEntityIdVarSpec);
computeInputVars.addAll(util.getCollectionMembers(collectionSpec));  // 20k gene columns
computeInputVars.addAll(idColumns);
connection.voidEval(util.getVoidEvalFreadCommand(INPUT_DATA, computeInputVars));
connection.voidEval("countData <- " + INPUT_DATA);
```

Creates wide format data that R expects.

### 5. R Processing
**method-differentialExpression.R:114-118** (DESeq example):
```r
# Remove ID columns and zero-only columns
cleanedData <- purrr::discard(collection@data[, -..allIdColumns], ...)

# Transpose: genes become ROWS, samples become COLUMNS
counts <- data.table::transpose(cleanedData)
rownames(counts) <- names(cleanedData)  # Column names → gene identifiers
colnames(counts) <- collection@data[[recordIdColumn]]  # Sample IDs
```

### 6. PointID Generation
The `pointID` in differential expression results comes from:
```
Collection → member variables → VariableDef objects →
entityId.variableId → wide column names → transpose →
rownames(counts) → pointID in output
```

**Critical**: PointIDs are currently `entityId.variableId` dot-notation strings.

---

## Proposed Data Flow (Tall Format)

### 1. New Data Structure
```
Samples as rows, normalized gene-expression observations:
sampleID | EUPA_0000123.VAR_bdc8e679 | EUPA_0000123.count
---------|---------------------------|-------------------
sample1  | ENSG00000001              | 42
sample1  | ENSG00000002              | 100
...
sample1  | ENSG00020000              | 0
sample2  | ENSG00000001              | 38
...
```

The gene column heading follows the standard `entityId.variableId` dot-notation (`EUPA_0000123.VAR_bdc8e679`).
The gene column **values** are the actual gene identifiers (e.g., `ENSG00000001`, `ENSG00000002`, etc.).

For 100 samples × 20,000 genes = 2,000,000 rows (vs. 100 rows × 20,000 columns)

### 2. Variable Collection Concept Evolution

**Important distinction**: EDA "variable collections" (organizational groupings of variables) are separate from R's `CountDataCollection` class (a data structure). These are independent concepts that happen to share the word "collection."

**EDA variable collections after going tall**:
- Will no longer be used to organize gene expression variables (since there are only 2 variables: gene ID and count/expression)
- May still be used for organizing sample metadata or other variable types
- Gene-level filtering/subsetting is handled externally (already implemented)

**Data model changes**:
- Only 2 actual variables for expression data:
  - Gene column (categorical/string, named `EUPA_0000123.VAR_bdc8e679`): contains actual gene IDs (e.g., `ENSG00000001`, `ENSG00000002`)
  - `count` or `expression` (numeric): the expression value

**Note**: The R code will still instantiate `CountDataCollection` objects, but these are simply data structures for holding wide-format count matrices. They have nothing to do with EDA's variable collection concept.

### 3. API/RAML Changes
**Current**: `entityId + collectionVariable`
**Proposed**: `entityId + valueVariable`

Where `valueVariable` is the numeric expression/count column.

The RAML schema will need to be updated to:
- Remove references to `collectionVariable` in differential expression endpoints
- Add `valueVariable` parameter (the count/expression column)
- Possibly add a `geneVariable` parameter (the gene identifier column)
- Document that EDA variable collections are no longer directly referenced in the API (filtering/subsetting happens before the plugin)

### 4. Required Java Changes

**Location**: `DifferentialExpressionPlugin.java:80-84`

**Current**:
```java
computeInputVars.addAll(util.getCollectionMembers(collectionSpec));  // 20k columns
connection.voidEval(util.getVoidEvalFreadCommand(INPUT_DATA, computeInputVars));
```

**Proposed** (conceptual):
```java
// Read tall format data stream (already filtered/subsetted to relevant genes)
connection.voidEval(util.getVoidEvalFreadCommand(INPUT_DATA, tallFormatVars));
// tallFormatVars includes: sampleID, gene column (e.g., EUPA_0000123.VAR_bdc8e679),
//                          count/expression, ancestorIDs

// Pivot from tall to wide format for R consumption
// The gene column values (ENSG00000001, ENSG00000002, etc.) become the new column names
String geneColName = toColNameOrEmpty(geneVariableSpec);  // e.g., "EUPA_0000123.VAR_bdc8e679"
connection.voidEval("countData <- dcast(" + INPUT_DATA +
                    ", " + sampleIDcol + " ~ `" + geneColName + "`" +
                    ", value.var = 'count')");
// Now countData has columns: sampleID, ENSG00000001, ENSG00000002, ..., ENSG00020000
// This is the wide format that CountDataCollection expects
```

This pivoting step is **the key change**. After pivoting, the gene IDs (from the values in the tall gene column) become column names in the wide format. The rest of the Java code proceeds unchanged.

### 5. Gene Identifier Handling

The gene **variable's** `stable_id` will be: **`VAR_bdc8e679`**

This means the gene column in tall format is named: **`EUPA_0000123.VAR_bdc8e679`** (using standard dot-notation)

The **values** in that column are the actual gene IDs: **`ENSG00000001`**, **`ENSG00000002`**, etc.

After pivoting, the wide format will have columns named after the gene IDs:
```
sampleID | ENSG00000001 | ENSG00000002 | ... | ENSG00020000
---------|--------------|--------------|-----|-------------
sample1  | 42           | 100          | ... | 0
```

**PointID derivation** remains the same conceptually:
```
Tall format: gene column values (ENSG00000001, ...) →
Pivot wide: gene IDs become column names →
Transpose: column names become rownames →
DESeq/limma output: rownames become pointID
```

**Output pointIDs will be the actual gene IDs** (e.g., `ENSG00000001`), no longer `entityId.variableId` dot-notation like `EUPA_0000123.ENSG00000001`.

### 6. R Code Changes
**Minimal to none**. The R `veupathUtils` package expects:
- `CountDataCollection` or `ArrayDataCollection` with samples as rows, genes as columns
- Wide format data

The validity checks in `class-CountDataCollection.R:9-30` verify:
- All non-ID columns are numeric ✓ (still true after pivot)
- Count data is integers ✓ (still true after pivot)
- No negative values for counts ✓ (still true after pivot)

The existing transpose and DESeq2/limma processing (method-differentialExpression.R:116-158, 189-241) work as-is.

---

## Migration Checklist

### RAML Schema
- [ ] Remove `collectionVariable` from differential expression request schema
- [ ] Add `valueVariable` (count/expression column) and optionally `geneVariable` (gene ID column)
- [ ] Update documentation: variable collections no longer used for expression data organization

### Java Layer (service-eda)
- [ ] Modify `DifferentialExpressionPlugin.java` to:
  - [ ] Accept `valueVariable` instead of `collectionVariable` in config
  - [ ] Read tall format data stream (gene column + count/expression column)
  - [ ] Pivot from tall to wide using `data.table::dcast()` with proper column quoting
  - [ ] Ensure gene ID **values** (ENSG00000001, etc.) become wide column names after pivot
  - [ ] Maintain ancestorID columns through the pivot
  - [ ] Still instantiate `CountDataCollection` object (R data structure, not related to EDA variable collections)
- [ ] Update sample metadata reading (already uses separate read, should work as-is)
- [ ] Test with real RNA-seq data (remove hack at lines 126-131)

### R Layer (veupathUtils)
- [ ] **No code changes required** - the R code is agnostic to EDA variable collections
- [ ] Verify `CountDataCollection` / `ArrayDataCollection` validation still works with pivoted data
- [ ] Confirm gene IDs (ENSG00000001, etc.) appear correctly in `pointID` field of results
- [ ] The `differentialExpression()`, `deseq()`, `limma()` functions work as-is

### Front-End
- [ ] Update configuration UI to select `valueVariable` instead of `collectionVariable`
- [ ] Handle pointIDs as actual gene IDs like `ENSG00000001` (no longer `entityId.variableId` dot-notation)
- [ ] Verify visualization plugins consume new pointID format correctly

### Data Layer / Subsetting
- [ ] Gene filtering/subsetting (already covered per notes)

---

## Benefits

1. **Front-end efficiency**: Metadata computation for 2 variables instead of 20,000
2. **UI simplicity**: No need to scroll through 20,000 variables
3. **Storage flexibility**: Sparse data representation possible
4. **Query efficiency**: Easier to filter by gene sets
5. **Minimal R changes**: Well-tested computation code remains stable

---

## Risks & Considerations

1. **Data volume in transit**: 2M rows vs. 100 rows (mitigated by subsetting before Java)
2. **Pivoting overhead**: Additional R computation step in Java layer
3. **Memory usage**: Pivot operation may temporarily require more memory
4. **PointID format change**: Downstream consumers must handle gene IDs instead of dot-notation

---

## References

### Key Code Files
- **Java**: `src/main/java/org/veupathdb/service/eda/compute/plugins/differentialexpression/DifferentialExpressionPlugin.java`
- **R**: `veupathUtils/R/method-differentialExpression.R`
- **R**: `veupathUtils/R/class-CountDataCollection.R`
- **R**: `veupathUtils/R/class-ArrayDataCollection.R`
- **Java Util**: `src/main/java/org/veupathdb/service/eda/common/plugin/util/PluginUtil.java`
- **Model**: `src/main/java/org/veupathdb/service/eda/common/model/VariableDef.java`

### Data Flow Summary
```
[Wide Format]
Tabular data → Java reads 20k columns → R CountDataCollection (wide) →
transpose → DESeq2/limma (genes as rows) → results with pointIDs

[Tall Format - Proposed]
Tabular data (tall) → Java reads 3 columns → Java pivots to wide →
R CountDataCollection (wide) → transpose → DESeq2/limma → results with pointIDs
```

---

## Questions for Consideration

1. Should pointIDs include `entityId.` prefix for consistency (e.g., `EUPA_0000123.ENSG00000001`), or just the gene IDs (e.g., `ENSG00000001`)?
2. How should the pivot handle duplicate sample-gene combinations (e.g., average, sum, first)?
3. What column name convention should be used post-pivot if gene IDs contain special characters?
4. Should we support both wide and tall formats during a transition period?

---

**Document Date**: 2026-01-09
**Status**: Planning / Pre-implementation
